# 面试相关

[TOC]



## 计算机网络

### TCP/IP

 #### 简述TCP三次握手的过程？

```
在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据
简版：首先A向B发SYN（同步请求），然后B回复SYN+ACK（同步请求应答），最后A回复ACK确认，这样TCP的一次连接（三次握手）的过程就建立了。
```

####  简述四次挥手的过程？

```
   由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
```

#### OSI七层和TCP/IP四层

| OSI七层网络模型 |    TCP/IP四层概念模型    |  对应网络协议    |
| --------------- | ---- | ---- |
| 应用层（Application）                | 应用层 | HTTP、TFTP, FTP, NFS, WAIS、SMTP |
|表示层（Presentation）                 | 应用层 | Telnet, Rlogin, SNMP, Gopher |
|会话层（Session）                 | 应用层 | SMTP, DNS |
|传输层（Transport）                 | 传输层 | TCP, UDP |
|网络层（Network）                 |网络层  | IP, ICMP, ARP, RARP, AKP, UUCP |
|数据链路层（Data Link）                 | 数据链路层 | FDDI, Ethernet, Arpanet, PDN, SLIP, PPP |
|物理层（Physical）                | 数据链路层 | IEEE 802.1A, IEEE 802.2到IEEE 802.11 |

#### OSI七层功能：

```
应用层（Application）:直接向用户提供服务，文件传输、电子邮件、文件服务、虚拟终端
表示层（Presentation）:数据格式化、代码转换、数据加密
会话层（Session）:在两个会话实体间建立和使用连接、解除连接
传输层（Transport）:提供可靠的端到端的差错和流量控制，保证报文的正确传输
网络层（Network）:通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。
数据链路层（Data Link）:传输有地址的帧，错误检测功能
物理层（Physical）:以二进制数据形式在物理媒体上传输数据
```




## 操作系统
### linux基础

#### 1、linux的启动过程

```
1、内核引导。当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。
2、运行init。init 进程是系统所有进程的起点，init程序首先是需要读取配置文件 /etc/inittab。
3、建立终端
4、用户登录系统
```
#### 2、介绍下cdn的作用

```
全称Content Delivery Network即内容分发网络。
CDN是一组分布在多个不同的地理位置的WEB服务器，用于更加有效的向用户发布内容，在优化性能时，会根据距离的远近来选择 。

CDN系统能实时的根据网络流量和各节点的连接，负载状况及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户能就近的获取请求数据，解决网络拥堵，提高访问速度，解决由于网络带宽小，用户访问量大，网点分布不均等原因导致的访问速度慢的问题。

```
#### 3、linux内核优化

```bash
关于内核参数的优化(/etc/sysctl.conf)：

net.ipv4.tcp_max_tw_buckets = 6000
timewait的数量，默认是180000。

#net.ipv4.ip_local_port_range = 1024    65000
允许系统打开的端口范围。

net.ipv4.tcp_tw_recycle = 1
启用timewait快速回收。

net.ipv4.tcp_tw_reuse = 1
开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。

net.ipv4.tcp_syncookies = 1
开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。

net.core.somaxconn = 262144
web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。

net.core.netdev_max_backlog = 262144
每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。

net.ipv4.tcp_max_orphans = 262144
系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。

net.ipv4.tcp_max_syn_backlog = 262144
记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。

net.ipv4.tcp_timestamps = 0
时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。

net.ipv4.tcp_synack_retries = 1
为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。

net.ipv4.tcp_syn_retries = 1
在内核放弃建立连接之前发送SYN包的数量。

net.ipv4.tcp_fin_timeout = 1
如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60 秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。

net.ipv4.tcp_keepalive_time = 30
当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时。
```



#### 4、linux系统初始化优化

```
1、yum源
2、关闭selinux
3、禁用root远程登录，ssh端口，普通用户sudo
4、时间同步
5、设置文件打开数
6、内核参数调优
7、升级内核设置BBR
8、锁定关键文件（chattr +i /etc/passwd）
9、去除系统登录屏幕提示（/etc/issue、/etc/issue.net）
10、关闭非必要服务
11、关闭Ctrl+Alt+Del来重启系统
12、设置rm -rf
13、精简开机系统启动
14、优化TCP
15、选择正确的文件系统
16、无操作自动登出
```

####  5、用tcpdump嗅探80端口的访问看看谁最高

```bash
tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr |head -5&nbsp;
```

#### 6、查出那个IP连接最多

```bash
netstat -na | grep ESTABLISH | awk '{print $5}' | awk -F: '{print $1}'| sort | uniq -c | sort -r
```

#### 7、查看Web服务器8082端口进程连接数

```bash
netstat -antp |grep 8082|grep ESTABLISHED -c
```



#### 8、tar排除多个目录压缩

```bash
tar -zcvf tomcat.tar.gz --exclude=tomcat/logs --exclude=tomcat/libs --exclude=tomcat/xiaoshan.txt tomcat
```



### windows

####  1、windows查看连接数

```basic
当前tcp链接数总量：
netstat -ant|find /C /I "TCP"
10.10.0.1的网络链接数：
netstat -ant|find /C /I "10.10.0.1"
```



## 中间件

#### 1、lvs、nginx、haproxy优缺点

```shell
Nginx优点：
1、工作在网络7层之上，可针对http应用做一些分流的策略，如针对域名、目录结构，它的正规规则比HAProxy更为强大和灵活，所以，目前为止广泛流行。
2、Nginx对网络稳定性的依赖非常小，理论上能ping通就能进行负载功能。
3、Nginx安装与配置比较简单，测试也比较方便，基本能把错误日志打印出来。
4、可以承担高负载压力且稳定，硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS小。
5、Nginx可以通过端口检测到服务器内部的故障，如根据服务器处理网页返回的状态码、超时等，并会把返回错误的请求重新提交到另一个节点。
6、不仅仅是优秀的负载均衡器/反向代理软件，同时也是强大的Web应用服务器。LNMP也是近些年非常流行的Web架构，在高流量环境中稳定性也很好。
7、可作为中层反向代理使用。
8、可作为静态网页和图片服务器
9、Nginx社区活跃，第三方模块非常多，相关的资料在网上比比皆是。
Nginx缺点：
1、适应范围较小，仅能支持http、https、Email协议。
2、对后端服务器的健康检查，只支持通过端口检测，不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。

LVS优点：
1、抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。
2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。
3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。
4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。
5、应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。
LVS的缺点：
1、软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。
2、如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。

HAProxy优点：
1、HAProxy是支持虚拟主机的，可以工作在4、7层(支持多网段)
2、HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。
3、HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。
4、HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。
5、HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种
roundrobin,leastconn,static-rr,source uri url_param hdr(name)　rdp-cookie（name）
HAPorxy缺点：
1. 不支持POP/SMTP协议
2. 不支持SPDY协议
3. 不支持HTTP cache功能。现在不少开源的lb项目，都或多或少具备HTTP cache功能。
4. 重载配置的功能需要重启进程，虽然也是soft restart，但没有Nginx的reaload更为平滑和友好。
5. 多进程模式支持不够好
```



### nginx
#### nginx负载均衡策略

```
1、轮询（默认）
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
2、权重
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
3、ip_hash
每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
4、fair（第三方）
按后端服务器的响应时间来分配请求，响应时间短的优先分配。
5、url_hash（第三方）
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
```

### lvs

#### 三种工作模式

```
1、基于NAT的LVS模式负载均衡
2、基于TUN的LVS负载均衡
3、基于DR的LVS负载均衡
```





### haproxy
### tomcat

#### Tomcat工作模式:

```
Tomcat是一个JSP/Servlet容器。其作为Servlet容器，有三种工作模式：
独立的Servlet容器、
进程内的Servlet容器、
进程外的Servlet容器。

进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：
Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；
Tomcat作为独立服务器：请求来自于web浏览器；
```



### apache
## 关系型数据库
### mysql
#### 1、mysql常用备份工具

```shell
1、备份类型：
按照备份的数据集的范围分为：完全备份和部分备份
按照备份的数据完整性分为:全量备份、增量备份、差异备份
根据数据服务是否在线分为：热备，温备，冷备。
按照备份方式分为：物理备份，逻辑备份。

2、备份工具：
mysqldump工具
cp/tar 拷贝复制文件
xtrabackup工具
mysqlhotcopy冷备工具
mysqlhotcopy冷备工具
select语句备份，只能备份部分
```
### oracle
### sqlserver
## 非关系型数据库
### redis

#### 1、什么是Redis？简述它的优缺点？

```
Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

Redis 与其他 key - value 缓存产品有以下三个特点：
1、Redis支持数据的持久化， RDB和AOF持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。
2、Redis支持丰富数据类型: String ，List，Set，Sorted Set，Hash 。
3、Redis丰富的特性，订阅发布 Pub / Sub 功能，Key 过期策略，事务，支持多个 DB，计数
4、Redis的速度快

redis的缺点
1、由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
2、redis是单线程的，单台服务器无法充分利用多核服务器的CPU
```

#### 2、Redis有哪些适合的场景

```
（1）会话缓存（Session Cache）
（2）全页缓存（FPC）
（3）队列
（4）排行榜/计数器
（5）发布/订阅

```



#### 3、redis支持的数据类型

```
redis是key-value的数据
键的类型是字符串
值的类型分为五种：
- 字符串string
- 哈希hash
- 列表list
- 集合set
- 有序集合zset
```
#### 4、Redis相比memcached有哪些优势？

```
(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
(2) redis的速度比memcached快很多
(3) redis可以持久化其数据
```

### elasticsearch

#### 1、什么是Elasticsearch?

```
Elasticsearch简称ES，是一个基于Lucene的实时分布式的搜索与分析引擎，是遵从Apache开源条款的一款开源产品，是当前主流的企业级搜索引擎。它提供了一个分布式服务，可以使您快速的近乎于准实时的存储、查询和分析超大数据集，通常被用来当做构建复杂查询特性和需求强大应用的基础引擎或技术。

```

#### 2、elasticsearch的适用场景

```
（1）维基百科，类似百度百科，全文检索，高亮，搜索推荐
（2）The Guardian（国外新闻网站），用户行为日志（点击，浏览，收藏，评论）+社交网络数据，数据分析
（3）Stack Overflow（国外的程序异常讨论论坛）
（4）GitHub（开源代码管理）
（5）电商网站，检索商品
（6）日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）
（7）商品价格监控网站
（8）BI系统，商业智能，Business Intelligence。
（9）国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景）
```



#### 3、elasticsearch的特点以及优势

```
横向可扩展性: 作为大型分布式集群，很容易就能扩展新的服务器到ES集群中；也可运行在单机上作为轻量级搜索引擎使用。
更丰富的功能: 与传统关系型数据库相比，ES提供了全文检索、同义词处理、相关度排名、复杂数据分析、海量数据的近实时处理等功能。
分片机制提供更好地分布性: 同一个索引被分为多个分片(Shard)，利用分而治之的思想提升处理效率。
高可用: 提供副本(Replica)机制，一个分片可以设置多个副本，即使在某些服务器宕机后，集群仍能正常工作。
开箱即用: 提供简单易用的 API，服务的搭建、部署和使用都很容易操作。

```

#### 4、Elasticsearch 是如何实现 Master 选举的？

```
前置前提：
（1）只有候选主节点（master：true）的节点才能成为主节点。
（2）最小主节点数（min_master_nodes）的目的是防止脑裂。

选举流程大致描述如下：
第一步：确认候选主节点数达标，elasticsearch.yml 设置的值
discovery.zen.minimum_master_nodes；
第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；
若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。
```



#### 5、描述一下 Elasticsearch 索引文档的过程

```
第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演路由节点的角色。）
第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。
第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。
```

#### 6、elasticsearch 的倒排索引是什么

```
传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。
而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了检索效率
```

#### 7、



### rabbitmq/rocketmq
### memcache
### mogondb
## python
## 监控
## 架构
监控：prometheus+grafana,zabbix,nagios.
apm：arms，CAT
## 容器
k8s,docker
## 日志收集
elk，efk
## 自动化
ansible，puppt，saltstack，蓝鲸
## 测试
压测：JMeter，LoadRunner，apache ab.
## 代码存储
git,gitlab,svn,码云,github.
## 反向面试
职责

- On-call (电话值班)的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？
- 我的日常工作是什么？
- 团队里面初级和高级工程师的比例是多少？（有计划改变吗）
- 入职培训会是什么样的？
- 自己单独的开发活动和按部就班工作的比例大概是怎样的？
- 每天预期/核心工作时间是多少小时？
- 在你看来，这个工作做到什么程度算成功？
- 我入职的岗位是新增还是接替之前离职的同事？(是否有技术债需要还)？(zh)
- 入职之后在哪个项目组，项目是新成立还是已有的？(zh)

技术

- 公司常用的技术栈是什么?
- 你们怎么使用源码控制系统？
- 你们怎么测试代码？
- 你们怎么追踪 bug?
- 你们怎么集成和部署代码改动？是使用持续集成和持续部署吗？
- 你们的基础设施搭建方法在版本管理系统里吗？或者是代码化的吗？
- 从计划到完成一项任务的工作流是什么样的？
- 你们如何准备故障恢复？
- 有标准的开发环境吗？是强制的吗？
- 你们需要花费多长时间来给产品搭建一个本地测试环境？（分钟/小时/天）
- 你们需要花费多长时间来响应代码或者依赖中的安全问题？
- 所有的开发者都可以使用他们电脑的本地管理员权限吗？
- 公司是否有技术分享交流活动？有的话，多久一次呢？(zh)
- 你们的数据库是怎么进行版本控制的？(zh)
- 业务需求有没有文档记录？是如何记录的？(zh)

团队

- 工作是怎么组织的？
- 团队内/团队间的交流通常是怎样的？
- 如果遇到不同的意见怎样处理？
- 谁来设定优先级 / 计划？
- 如果被退回了会怎样？（“这个在预计的时间内做不完”）
- 每周都会开什么类型的会议？
- 产品/服务的规划是什么样的？（n周一发布 / 持续部署 / 多个发布流 / ...)
- 生产环境发生事故了怎么办？是否有不批评人而分析问题的文化？
- 有没有一些团队正在经历还尚待解决的挑战？
- 公司技术团队的架构和人员组成？(zh)

公司

- 有没有会议/旅行预算？使用的规定是什么？
- 晋升流程是怎样的？要求/预期是怎样沟通的？
- 技术和管理两条职业路径是分开的吗？
- 对于多元化招聘的现状或者观点是什么？
- 有公司级别的学习资源吗？比如电子书订阅或者在线课程？
- 有获取证书的预算吗？
- 公司的成熟度如何？（早期寻找方向 / 有内容的工作 / 维护中 / ...)
- 我可以为开源项目做贡献吗？是否需要审批？
- 有竞业限制或者保密协议需要签吗？
- 你们认为公司文化中的空白是什么？
- 能够跟我说一公司处于不良情况，以及如何处理的故事吗？

商业

- 你们现在盈利吗？
- 如果没有的话，还需要多久？
- 公司的资金来源是什么？谁影响或者指定高层计划或方向？
- 你们如何挣钱？
- 什么阻止了你们挣更多的钱？
- 你们认为什么是你们的竞争优势？

远程工作

- 远程工作和办公室工作的比例是多少？
- 公司提供硬件吗？更新计划如何？
- 额外的附件和家居可以通过公司购买吗？这方面是否有预算？
- 有共享办公或者上网的预算吗？
- 多久需要去一次办公室？
- 公司的会议室是否一直为视频会议准备着？

办公室工作

- 办公室的布局如何？（开放的 / 小隔间 / 独立办公室）
- 有没有支持/市场/或者其他需要大量打电话的团队在我的团队旁边办公？

待遇

- 如果有奖金计划的话，奖金如何分配？
- 如果有奖金计划的话，过去的几年里通常会发百分之多少的奖金？
- 有五险一金或者其他退休养老金等福利吗？如果有的话，公司有配套的商业保险吗？

带薪休假

- 带薪休假时间有多久？
- 病假和事假是分开的还是一起算？
- 我可以提前使用假期时间吗？也就是说应休假期是负的？
- 假期的更新策略是什么样的？也就是说未休的假期能否滚入下一周期
- 照顾小孩的政策如何？
- 无薪休假政策是什么样的？